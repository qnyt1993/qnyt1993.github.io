---
title: 51单片机实现独立按键计数数码管显示
tags: [单片机]
categories: [硬件,单片机,51]
date: 2019-10-04 15:27:47
---

#### 1. 开发环境

> 单片机: stc89c52
>
> 开发板: Hot51单片机增强版

#### 2. 电路图

![](https://i.loli.net/2019/10/29/vFQuIynsqjwT1YX.png)


#### 3. 程序代码

##### 3.1 程序代码1（利用延时实现消抖）

    #include<reg52.h>
    #define uchar unsigned char
    #define uint  unsigned int
    
    sbit KEY1 = P3^2;
    
    uchar code LedChar[]= {  //数码管显示字符编码数组
    
        0x3F,  //"0"
        0x06,  //"1"
        0x5B,  //"2"
        0x4F,  //"3"
        0x66,  //"4"
        0x6D,  //"5"
        0x7D,  //"6"
        0x07,  //"7"
        0x7F,  //"8"
        0x6F,  //"9"
        0x77,  //"A"
        0x7C,  //"B"
        0x39,  //"C"
        0x5E,  //"D"
        0x79,  //"E"
        0x71     // "F"
    };
    
    uchar code LedWei[] = {7,6,5,4,3,2,1,0 };                              //八位数码管的位置值
    uchar LedBuff[] = {0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F};    //八位数码管应该显示的值
    
    void showLED(uint num);
    
    void delay() {
        uint i = 1000;
        while(i--);
    }
    
    void main() {
        uint num = 0;			//按键计数初值
        bit keybuf = 1;		//临时保存按键的扫描值
        bit backup = 1;			//定义一个位变量，保存前一次扫描的按键值
        EA = 1;							//开启总中断
        TMOD = 0x01;    		//设置定时器0为一个16位的定时器
        TH0 = 0xFC;        	//因为定时器分高八位和低八位，根据累加到溢出从而实现定时，因此需要给定时器0设置累加初值
        TL0 = 0x66;        	//设置每次定时1ms
        ET0 = 1;						//使能T0中断
        TR0 = 1;            //开启定时器
    
        while(1) {
            keybuf = KEY1;
    
            if(keybuf != backup) { //当前值与前次值不相等说明此时按键有动作
                delay();
                if(keybuf == KEY1)	//判断按键有无发生按键抖动
                {
                    if(backup == 0)	//如果前次值为0，说明当前值是由0变1，即按键弹起操作
                    {
                        num++;			//按键次数加1
                        showLED(num);	//调用计算数码管显示值的方法，更新最新的计数值显示数组
                    }
    
                    backup = keybuf;	//更新备份值为当前值，以备进行下次比较
                }
            }
    
        }
    }
    
    /*
    * 计算当前八位数码管每个位置应该显示的值
    */
    void showLED(uint num) {
        LedBuff[0] = LedChar[num%10];
        LedBuff[1] = LedChar[num/10%10];
        LedBuff[2] = LedChar[num/100%10];
        LedBuff[3] = LedChar[num/1000%10];
        LedBuff[4] = LedChar[num/10000%10];
        LedBuff[5] = LedChar[num/100000%10];
        LedBuff[6] = LedChar[num/1000000%10];
        LedBuff[7] = LedChar[num/10000000%10];
    }
    
    void InterruptTimer0()  interrupt 1        //定时器0触发的中断
    {
        static uchar i = 0;
    
        TH0 = 0xFC;            //重新设置定时器0的初始值
        TL0 = 0x66;
    
        P2 = LedWei[i];        //设置显示当前数码管需要展示的位置
        P0 = LedBuff[i];    	//设置当前数码管要展示的值
    
        if(i == 7) {
            i = 0;
        } else {
            i++;
        }
    }
    
##### 3.2 程序代码2(推荐使用)   
 
 
     #include<reg52.h>
     #define uchar unsigned char
     #define uint  unsigned int
     
     sbit KEY1 = P3^2;
     
     uchar code LedChar[]= {  //数码管显示字符编码数组
     
         0x3F,  //"0"
         0x06,  //"1"
         0x5B,  //"2"
         0x4F,  //"3"
         0x66,  //"4"
         0x6D,  //"5"
         0x7D,  //"6"
         0x07,  //"7"
         0x7F,  //"8"
         0x6F,  //"9"
         0x77,  //"A"
         0x7C,  //"B"
         0x39,  //"C"
         0x5E,  //"D"
         0x79,  //"E"
         0x71     // "F"
     };
     
     uchar code LedWei[] = {7,6,5,4,3,2,1,0 };                              //八位数码管的位置值
     uchar LedBuff[] = {0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F};    //八位数码管应该显示的值
     
     bit KeySta = 1;		//当前按键的状态是按下还是松开状态
     
     void showLED(uint num);
     
     
     void main() {
         uint num = 0;			//按键计数初值
         bit backup = 1;			//定义一个位变量，保存前一次扫描的按键值
         EA = 1;							//开启总中断
         TMOD = 0x01;    		//设置定时器0为一个16位的定时器
         TH0 = 0xF8;        	//因为定时器分高八位和低八位，根据累加到溢出从而实现定时，因此需要给定时器0设置累加初值
         TL0 = 0xCD;        	//设置每次定时2ms
         ET0 = 1;						//使能T0中断
         TR0 = 1;            //开启定时器
     
         while(1) {
             if(KeySta != backup) { //当前值与前次值不相等说明此时按键有动作
                 if(backup == 0)	//如果前次值为0，说明当前值是由0变1，即按键弹起操作
                 {
                     num++;			//按键次数加1
                     showLED(num);	//调用计算数码管显示值的方法，更新最新的计数值显示数组
                 }
     
                 backup = KeySta;	//更新备份值为当前值，以备进行下次比较
             }
         }
     }
     
     /*
     * 计算当前八位数码管每个位置应该显示的值
     */
     void showLED(uint num) {
         LedBuff[0] = LedChar[num%10];
         LedBuff[1] = LedChar[num/10%10];
         LedBuff[2] = LedChar[num/100%10];
         LedBuff[3] = LedChar[num/1000%10];
         LedBuff[4] = LedChar[num/10000%10];
         LedBuff[5] = LedChar[num/100000%10];
         LedBuff[6] = LedChar[num/1000000%10];
         LedBuff[7] = LedChar[num/10000000%10];
     }
     
     void InterruptTimer0()  interrupt 1        //定时器0触发的中断,扫描按键状态并消抖
     {
         static uchar i = 0;
         static uchar keybuf = 0xff; 	//扫描缓冲区，用于存储最近8次扫描的按键状态值
     
         TH0 = 0xF8;            //重新设置定时器0的初始值
         TL0 = 0xCD;
     
         keybuf = (keybuf << 1) | KEY1;
         if(keybuf == 0x00) {		//表明连续的8次检测按键状态均为按下状态，即16ms内按键状态均为按下状态，即可认为按键已经按下
             KeySta = 0;
         } else if(keybuf == 0xff) { //表明连续的8次检测按键状态均为弹起状态，即16ms内按键状态均为弹起状态，即可认为按键已经弹起
             KeySta = 1;
         } else{
         }
     
         P2 = LedWei[i];        //设置显示当前数码管需要展示的位置
         P0 = LedBuff[i];    	//设置当前数码管要展示的值
     
         if(i == 7) {
             i = 0;
         } else {
             i++;
         }
     }
     
     